Демонстрация SOLID принципов
Цель:

Практическое применение SOLID принципов.

На примере реализации игры «Угадай число» продемонстрировать практическое применение SOLID принципов.
Программа рандомно генерирует число, пользователь должен угадать это число. При каждом вводе числа программа пишет больше или меньше отгадываемого. Кол-во попыток отгадывания и диапазон чисел должен задаваться из настроек.
В отчёте написать, что именно сделано по каждому принципу. 


ОТЧЕТ
>>> SOLID:

S <- Single responsibility principle:

Классы DigitChecker, DigitGenerator, Messager, Settings предназначены для выполнения
одной функции

O <- Open/close principle:
Классы DigitGenerator, DigitChecker закрывает доступ к собственной модификаци, но открыты
возможности для изменения метода генерации числа (GenerateNewValue) и доступа с "загаданному числу" (GetHiddenNumber)
Продемонстировано в классах DigitGeneratorLiskov, DigitCheckerLickov

L <- Liskov substitution principle:
Классы DigitCheckerLickov, DigitGeneratorLiskov расширяют функционал классов родителей DigitChecker, DigitGeneratorLiskov.
При этом сохраняется оригинальное поведение, в любом месте, где это требуется, можно использовать
DigitCheckerLickov, DigitGeneratorLiskov вместо их родителей и получить "ожидаемый" результат.

I <- Interface segregation principle:

Все интерфейсы сожержат минимум требований для реализации, необходимый для функционирования классов наследников.
Например ISettings требует реализовать три параметра, которые нужны для конструктора класса NumberGuesser
для чего и был создан данный интерфейс.

D <- Dependency inversion principle
Во всех классах, где посчитал это необходимым (ввиду возможной необходимости дальнейшего их изменения)
все зависимости сделаны на интерфейсы, что позволяет абстрагироваться от реализации, т.е. зависеть от абстракций
